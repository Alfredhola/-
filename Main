<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>RG Golf Pairing Pro</title>
    <style>
        :root {
            --primary: #1e4d2b;       /* Masters Green */
            --primary-light: #e8f5e9;
            --accent: #d4a017;        /* Gold/Sand */
            --bg: #f0f2f5;
            --white: #ffffff;
            --text-dark: #1a1a1a;
            --text-gray: #5f6368;
            --border: #dadce0;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --radius: 12px;
            
            --male-color: #1976d2;
            --female-color: #c2185b;
            --error: #d32f2f;
            --success: #2e7d32;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg);
            color: var(--text-dark);
            margin: 0;
            padding: 0;
            line-height: 1.5;
            -webkit-font-smoothing: antialiased;
        }

        /* Layout & Container */
        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        header {
            background: var(--white);
            padding: 16px 20px;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 0 0 var(--radius) var(--radius);
            margin-bottom: 20px;
        }

        header h1 {
            margin: 0;
            font-size: 20px;
            font-weight: 800;
            color: var(--primary);
            letter-spacing: -0.5px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .version-badge {
            background: var(--primary-light);
            color: var(--primary);
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 10px;
            font-weight: 700;
        }

        /* Stepper */
        .stepper {
            display: flex;
            background: var(--white);
            padding: 6px;
            border-radius: 50px;
            margin-bottom: 24px;
            box-shadow: var(--shadow);
        }

        .step-item {
            flex: 1;
            text-align: center;
            padding: 10px;
            font-size: 14px;
            font-weight: 600;
            color: var(--text-gray);
            cursor: pointer;
            border-radius: 40px;
            transition: all 0.3s ease;
        }

        .step-item.active {
            background-color: var(--primary);
            color: var(--white);
            box-shadow: 0 2px 4px rgba(30, 77, 43, 0.3);
        }

        /* Cards */
        .card {
            background: var(--white);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 24px;
            margin-bottom: 20px;
            animation: fadeIn 0.4s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        h2 {
            margin: 0 0 16px 0;
            font-size: 18px;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        h2::before {
            content: '';
            display: block;
            width: 4px;
            height: 20px;
            background: var(--accent);
            border-radius: 2px;
        }

        /* Forms & Inputs */
        textarea {
            width: 100%;
            height: 200px;
            padding: 16px;
            border: 2px solid var(--border);
            border-radius: var(--radius);
            font-size: 16px;
            font-family: monospace;
            resize: none;
            box-sizing: border-box;
            transition: 0.2s;
            background: #fafafa;
        }

        textarea:focus {
            outline: none;
            border-color: var(--primary);
            background: #fff;
        }

        .input-helper {
            font-size: 13px;
            color: var(--text-gray);
            margin-bottom: 12px;
            background: var(--primary-light);
            padding: 10px;
            border-radius: 8px;
            line-height: 1.6;
        }

        /* Buttons */
        .btn {
            width: 100%;
            padding: 14px;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-top: 10px;
        }

        .btn:active { transform: scale(0.98); }
        .btn:disabled { background: #ccc !important; cursor: not-allowed; }

        .btn-primary { background: var(--primary); color: white; box-shadow: 0 4px 12px rgba(30, 77, 43, 0.2); }
        .btn-secondary { background: var(--white); border: 2px solid var(--border); color: var(--text-gray); }
        .btn-success { background: var(--success); color: white; }
        .btn-ghost { background: transparent; color: var(--text-gray); font-size: 14px; width: auto; padding: 8px 16px; }

        /* Step 2: List */
        .player-row {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px;
            border-bottom: 1px solid var(--border);
            background: white;
            transition: 0.2s;
        }
        .player-row:last-child { border-bottom: none; }
        .player-row:hover { background: #f9f9f9; }

        .gender-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            border: 1px solid var(--border);
            cursor: pointer;
            flex-shrink: 0;
            transition: 0.2s;
        }
        .gender-btn.male { background: #e3f2fd; color: var(--male-color); border-color: #bbdefb; }
        .gender-btn.female { background: #fce4ec; color: var(--female-color); border-color: #f8bbd0; }

        .name-input {
            flex: 1;
            border: none;
            background: transparent;
            font-size: 16px;
            font-weight: 500;
            color: var(--text-dark);
            padding: 5px;
        }
        .name-input:focus { outline: none; border-bottom: 2px solid var(--accent); }

        .hcp-badge {
            background: var(--bg);
            padding: 4px 8px;
            border-radius: 6px;
            font-weight: 700;
            font-size: 14px;
            color: var(--text-gray);
            width: 45px;
            text-align: center;
            border: 1px solid var(--border);
        }

        .btn-icon {
            background: none; border: none; font-size: 20px; color: #ef5350; cursor: pointer; padding: 5px;
        }

        /* Settings Grid */
        .settings-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--border);
        }
        .setting-item label {
            display: block;
            font-size: 12px;
            font-weight: 700;
            color: var(--text-gray);
            margin-bottom: 6px;
            text-transform: uppercase;
        }
        .setting-item select {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: white;
            font-size: 14px;
        }

        /* Step 3: Scorecards */
        .scorecard {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: var(--shadow);
            margin-bottom: 20px;
            border-left: 6px solid var(--primary);
            position: relative;
        }
        .scorecard.invalid {
            border-left-color: var(--error);
        }
        .scorecard.invalid::after {
            content: '‚ö†Ô∏è ‰∫∫Êï∏ÈúÄÁÇ∫ 3 Êàñ 4 ‰∫∫';
            position: absolute;
            top: 10px;
            right: 50px; /* space for arrows */
            font-size: 11px;
            color: var(--error);
            font-weight: bold;
            background: #ffebee;
            padding: 2px 6px;
            border-radius: 4px;
        }

        .sc-header {
            padding: 12px 16px;
            background: #f8f9fa;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .sc-title { font-weight: 800; color: var(--primary); font-size: 15px; }
        .sc-stats { font-size: 12px; color: var(--text-gray); background: #eee; padding: 2px 8px; border-radius: 10px; }

        .sc-table { width: 100%; border-collapse: collapse; }
        .sc-table td { padding: 10px 16px; border-bottom: 1px solid #f0f0f0; vertical-align: middle; }
        .sc-table tr:last-child td { border-bottom: none; }
        
        .p-name { font-weight: 600; font-size: 15px; display: block; }
        .p-name.male { color: var(--male-color); }
        .p-name.female { color: var(--female-color); }
        
        .move-select {
            font-size: 11px;
            color: var(--text-gray);
            border: 1px solid #eee;
            border-radius: 4px;
            padding: 2px;
            margin-top: 4px;
            background: white;
        }

        .sc-controls { display: flex; gap: 4px; }
        .arrow-btn {
            width: 28px; height: 28px;
            border: 1px solid #eee; background: white;
            border-radius: 6px; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            color: var(--text-gray);
        }
        .arrow-btn:hover { background: var(--primary); color: white; border-color: var(--primary); }

        /* Toast */
        #toast {
            visibility: hidden;
            min-width: 250px;
            background-color: #323232;
            color: #fff;
            text-align: center;
            border-radius: 8px;
            padding: 14px;
            position: fixed;
            z-index: 999;
            left: 50%;
            bottom: 30px;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s, bottom 0.3s;
            font-size: 14px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        #toast.show { visibility: visible; opacity: 1; bottom: 40px; }

        .hidden { display: none !important; }
        
        /* Add Player Row */
        .add-player-row {
            display: flex; gap: 8px; background: var(--primary-light); padding: 10px; border-radius: 8px; margin-bottom: 10px;
        }
    </style>
</head>
<body>

<header>
    <h1>‚õ≥Ô∏è RG PAIRING <span class="version-badge">PRO</span></h1>
</header>

<div class="container">

    <!-- Step Navigation -->
    <div class="stepper">
        <div class="step-item active" id="tab-1" onclick="app.goToStep(1)">1. ÂêçÂñÆËº∏ÂÖ•</div>
        <div class="step-item" id="tab-2" onclick="app.goToStep(2)">2. Á∑®ËºØË®≠ÂÆö</div>
        <div class="step-item" id="tab-3">3. ÂàÜÁµÑÁµêÊûú</div>
    </div>

    <!-- VIEW 1: Input -->
    <div id="view-1">
        <div class="card">
            <h2><span style="font-size:24px;">üìù</span> Ëº∏ÂÖ•ÂêçÂñÆ</h2>
            <div class="input-helper">
                üí° ÊîØÊè¥Ê†ºÂºèÔºöÂßìÂêç + Â∑ÆÈªû (‰∏ÄË°å‰∏Ä‰∫∫)<br>
                ‰æãÂ¶ÇÔºö<code>ÁéãÂ∞èÊòé 18</code> Êàñ <code>Jason Day 2</code><br>
                Á≥ªÁµ±Â∞áËá™ÂãïËæ®Ë≠òÊÄßÂà•Ëàá‰∏≠ÊñáÂßìÂêçÂÑ™ÂÖàÊéíÂ∫è„ÄÇ
            </div>
            <textarea id="input-text" placeholder="Ë≤º‰∏äÂêçÂñÆÊñºÊ≠§...&#10;Âºµ‰∏â 12&#10;Mary 24&#10;ÊùéÂõõ 18"></textarea>
            
            <button class="btn btn-primary" onclick="app.processInput()">‰∏ã‰∏ÄÊ≠•ÔºöËß£ÊûêÂêçÂñÆ ‚ûî</button>
            <div style="display:flex; justify-content: center; gap: 10px; margin-top: 15px;">
                <button class="btn btn-ghost" onclick="app.loadDemo()">ËºâÂÖ•ÁØÑ‰æã</button>
                <button class="btn btn-ghost" onclick="app.clearInput()" style="color:#ef5350;">Ê∏ÖÁ©∫</button>
            </div>
        </div>
    </div>

    <!-- VIEW 2: Edit & Configure -->
    <div id="view-2" class="hidden">
        <div class="card">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
                <h2><span style="font-size:24px;">‚öôÔ∏è</span> Á∑®ËºØËàáË®≠ÂÆö</h2>
                <span id="player-count-badge" class="version-badge" style="font-size:13px;">0 ‰∫∫</span>
            </div>

            <!-- Quick Add -->
            <div class="add-player-row">
                <input id="new-name" class="name-input" style="background:white; border-radius:4px; padding:8px;" placeholder="Êñ∞Â¢ûÂßìÂêç...">
                <input id="new-hcp" type="number" class="hcp-badge" style="width:60px; background:white;" placeholder="HCP">
                <button class="btn-primary" style="width:auto; margin:0; padding:0 15px; border-radius:6px;" onclick="app.manualAdd()">+</button>
            </div>

            <!-- List -->
            <div id="player-list-container" style="max-height: 400px; overflow-y: auto; border: 1px solid var(--border); border-radius: 8px;">
                <!-- Items injected here -->
            </div>

            <!-- Settings -->
            <div class="settings-grid">
                <div class="setting-item">
                    <label>‚öñÔ∏è ÂàÜÁµÑÁ≠ñÁï•</label>
                    <select id="hcp-strategy">
                        <option value="balanced_snake" selected>Á∏ΩÂíåÂπ≥Âùá (SÂûãÊéíÂ∫è)</option>
                        <option value="competitive">ÂØ¶ÂäõÂàÜÂ±§ (Âº∑Âº∑/Âº±Âº±)</option>
                        <option value="random">ÂÆåÂÖ®Èö®Ê©ü</option>
                    </select>
                </div>
                <div class="setting-item">
                    <label>üë´ ÊÄßÂà•ÂàÜÈÖç</label>
                    <select id="gender-strategy">
                        <option value="mixed" selected>Âπ≥ÂùáÊ∑∑Á∑®</option>
                        <option value="separate">Áî∑Â•≥ÂàÜÈñã</option>
                    </select>
                </div>
            </div>

            <button class="btn btn-primary" onclick="app.generatePairings()">ÈñãÂßãÂàÜÁµÑ ‚õ≥</button>
        </div>
    </div>

    <!-- VIEW 3: Results -->
    <div id="view-3" class="hidden">
        <div class="card" style="padding: 16px; background: var(--primary-light); border: 1px solid var(--primary);">
            <div style="display:flex; justify-content: space-between; font-size: 13px; font-weight:bold; color:var(--primary);">
                <span id="res-total-players"></span>
                <span id="res-group-structure"></span>
            </div>
        </div>

        <div id="results-container"></div>

        <div style="display:flex; gap:10px; margin-top:20px;">
            <button class="btn btn-secondary" onclick="app.goToStep(1)">‚Ü∫ ÈáçÊñ∞ÈñãÂßã</button>
            <button id="btn-export" class="btn btn-success" onclick="app.copyToClipboard()">üìã Ë§áË£ΩÊñáÂ≠óÂêçÂñÆ</button>
        </div>
        <div style="height: 40px;"></div>
    </div>

</div>

<div id="toast">Message</div>

<script>
/**
 * RG Golf Pairing App Logic
 * Designed for strict 3-4 person grouping.
 */
const app = {
    data: {
        players: [],
        groups: [],
        idCounter: 1
    },
    
    config: {
        minGroup: 3,
        maxGroup: 4
    },

    // --- Navigation ---
    goToStep: (step) => {
        document.querySelectorAll('.step-item').forEach(el => el.classList.remove('active'));
        document.getElementById(`tab-${step}`).classList.add('active');
        
        ['view-1', 'view-2', 'view-3'].forEach(id => document.getElementById(id).classList.add('hidden'));
        document.getElementById(`view-${step}`).classList.remove('hidden');
        window.scrollTo(0, 0);
    },

    showToast: (msg) => {
        const t = document.getElementById("toast");
        t.innerText = msg;
        t.className = "show";
        setTimeout(() => { t.className = t.className.replace("show", ""); }, 3000);
    },

    // --- Step 1: Input & Parsing ---
    loadDemo: () => {
        document.getElementById('input-text').value = 
`Tiger Woods 0
Rory McIlroy 2
Scottie Scheffler 1
Nelly Korda üëë 2
Lydia Ko 4
Viktor Hovland 3
Jon Rahm 2
Minjee Lee 5
Jordan Spieth 4
Justin Thomas 3
Brooke Henderson 6
Collin Morikawa 3
Rickie Fowler 5
Lexi Thompson 4`;
    },

    clearInput: () => {
        document.getElementById('input-text').value = '';
    },

    processInput: () => {
        const rawText = document.getElementById('input-text').value;
        if (!rawText.trim()) {
            app.showToast("Ë´ãËº∏ÂÖ•ÂêçÂñÆ");
            return;
        }

        app.data.players = [];
        app.data.idCounter = 1;
        
        const lines = rawText.split('\n');
        const femaleKeywords = ["Mrs", "Ms", "Miss", "Lady", "Â•≥", "Âßê", "Â¶π", "üëë", "üåπ", "‚ù§Ô∏è", "ü©∑"];
        
        lines.forEach(line => {
            let clean = line.trim();
            if (!clean) return;

            // Remove starting numbering (e.g. "1. ")
            clean = clean.replace(/^[\d\.\s\)\-\]]+/, '');

            // Extract HCP (last number)
            let hcp = 0;
            const hcpMatch = clean.match(/(\d+(\.\d+)?)$/);
            if (hcpMatch) {
                hcp = parseFloat(hcpMatch[0]);
                clean = clean.substring(0, hcpMatch.index).trim();
            }

            // Detect Gender
            let isFemale = false;
            if (new RegExp(femaleKeywords.join('|'), 'i').test(clean)) isFemale = true;
            // Common names heuristic (optional, simplified)
            if (/Amy|Lisa|Jennifer|Sarah|Jessica|Nelly|Lydia|Minjee|Lexi|Brooke/i.test(clean)) isFemale = true;

            // Clean Name (remove emojis/keywords if needed, but keeping them is usually fine for display)
            // Let's just remove the specific gender keywords to clean up a bit
            let displayName = clean; // Keep original for flair

            // Chinese Sorting Helper: Put Chinese chars first if mixed? 
            // The prompt asked for optimized UX. Standard logic: Chinese name + English name.
            // Let's rely on the user's input order but we can detect Chinese char.
            
            app.data.players.push({
                id: app.data.idCounter++,
                name: displayName,
                hcp: hcp,
                gender: isFemale ? 'F' : 'M'
            });
        });

        app.updatePlayerCount();
        app.renderPlayerList();
        app.goToStep(2);
    },

    // --- Step 2: Edit ---
    updatePlayerCount: () => {
        document.getElementById('player-count-badge').innerText = `ÂÖ± ${app.data.players.length} ‰∫∫`;
    },

    renderPlayerList: () => {
        const container = document.getElementById('player-list-container');
        container.innerHTML = '';
        
        app.data.players.forEach(p => {
            const div = document.createElement('div');
            div.className = 'player-row';
            div.innerHTML = `
                <div class="gender-btn ${p.gender === 'M' ? 'male' : 'female'}" 
                     onclick="app.toggleGender(${p.id})">
                     ${p.gender === 'M' ? '‚ôÇ' : '‚ôÄ'}
                </div>
                <input class="name-input" value="${p.name}" onchange="app.updateName(${p.id}, this.value)">
                <input type="number" class="hcp-badge" value="${p.hcp}" onchange="app.updateHcp(${p.id}, this.value)">
                <button class="btn-icon" onclick="app.deletePlayer(${p.id})">√ó</button>
            `;
            container.appendChild(div);
        });
    },

    manualAdd: () => {
        const nameIn = document.getElementById('new-name');
        const hcpIn = document.getElementById('new-hcp');
        const name = nameIn.value.trim();
        if(name) {
            app.data.players.push({
                id: app.data.idCounter++,
                name: name,
                hcp: parseFloat(hcpIn.value) || 0,
                gender: 'M' // Default
            });
            nameIn.value = '';
            hcpIn.value = '';
            app.updatePlayerCount();
            app.renderPlayerList();
            // Scroll to bottom
            const container = document.getElementById('player-list-container');
            setTimeout(() => container.scrollTop = container.scrollHeight, 100);
        }
    },

    deletePlayer: (id) => {
        app.data.players = app.data.players.filter(p => p.id !== id);
        app.updatePlayerCount();
        app.renderPlayerList();
    },

    toggleGender: (id) => {
        const p = app.data.players.find(x => x.id === id);
        if(p) {
            p.gender = p.gender === 'M' ? 'F' : 'M';
            app.renderPlayerList();
        }
    },

    updateName: (id, val) => { app.data.players.find(x => x.id === id).name = val; },
    updateHcp: (id, val) => { app.data.players.find(x => x.id === id).hcp = parseFloat(val) || 0; },

    // --- Step 3: Algorithm (The Core) ---
    calculateGroupStructure: (total) => {
        // Solves N = 4x + 3y to maximize x (groups of 4)
        if (total < 3) return null;
        if (total === 5) return null; // Impossible strictly 3 or 4

        let remainder = total % 4;
        let count4 = Math.floor(total / 4);
        let count3 = 0;

        if (remainder === 0) {
            // Perfect 4s
        } else if (remainder === 1) {
            // Need to convert three 4s into four 3s? No.
            // Example: 9. 4+4 (+1) -> 3+3+3. (Convert two 4s -> +1 -> three 3s)
            // Example: 5. 4 (+1) -> Impossible.
            // Example: 13. 4,4,4 (+1) -> 4,3,3,3. (Reduce 4s by 2, Add 3s by 3?) 
            // Let's just decrement count4 until remaining is divisible by 3.
            
            while (count4 >= 0) {
                let left = total - (count4 * 4);
                if (left > 0 && left % 3 === 0) {
                    count3 = left / 3;
                    break;
                }
                count4--;
            }
        } else if (remainder === 2) {
            // Example: 6. 4 (+2) -> 3,3.
            // Example: 10. 4,4 (+2) -> 4,3,3.
            while (count4 >= 0) {
                let left = total - (count4 * 4);
                if (left > 0 && left % 3 === 0) {
                    count3 = left / 3;
                    break;
                }
                count4--;
            }
        } else if (remainder === 3) {
            // Perfect. One 3.
            count3 = 1;
        }

        // Verify
        if (count4 * 4 + count3 * 3 !== total) return null; // Should capture 5

        // Create structure array [4,4,4,3,3] etc.
        let structure = [];
        for(let i=0; i<count4; i++) structure.push(4);
        for(let i=0; i<count3; i++) structure.push(3);
        return structure;
    },

    generatePairings: () => {
        const pool = [...app.data.players]; // Copy
        const total = pool.length;
        
        // 1. Determine Structure
        const structure = app.calculateGroupStructure(total);
        
        if (!structure) {
            app.showToast("‚ùå ÁÑ°Ê≥ïÂàÜÁµÑÔºö‰∫∫Êï∏ÂøÖÈ†àËÉΩË¢´3Êàñ4Êï¥Èô§ (5‰∫∫‰∏çË°å)");
            return;
        }

        // 2. Sort Logic
        const hcpStrategy = document.getElementById('hcp-strategy').value;
        const genderStrategy = document.getElementById('gender-strategy').value;

        // Sorting Helper
        const sortByHcpDesc = (arr) => arr.sort((a,b) => b.hcp - a.hcp);
        const sortByHcpAsc = (arr) => arr.sort((a,b) => a.hcp - b.hcp);

        // Prepare Groups
        let groups = structure.map(size => ({ capacity: size, members: [] }));
        
        if (hcpStrategy === 'random') {
            pool.sort(() => Math.random() - 0.5);
            let pIdx = 0;
            groups.forEach(g => {
                for(let i=0; i<g.capacity; i++) g.members.push(pool[pIdx++]);
            });
        } else if (hcpStrategy === 'competitive') {
            // Low HCP play together
            sortByHcpAsc(pool);
            let pIdx = 0;
            groups.forEach(g => {
                for(let i=0; i<g.capacity; i++) g.members.push(pool[pIdx++]);
            });
        } else {
            // Balanced Snake
            let listToDistribute = [];

            if (genderStrategy === 'separate') {
                // Not strictly separate groups, but fill ladies first then men?
                // Or separate groups entirely? Assuming separate groups is hard with 4/3 constraints.
                // Let's interpret as "Sort ladies together, then men together" for snake
                let ladies = pool.filter(p => p.gender === 'F');
                let men = pool.filter(p => p.gender === 'M');
                sortByHcpDesc(ladies);
                sortByHcpDesc(men);
                listToDistribute = [...ladies, ...men];
            } else {
                // Mixed
                listToDistribute = pool;
                sortByHcpDesc(listToDistribute);
            }

            // Snake Distribution
            // Since groups have different capacities (4 and 3), "column" snake is tricky.
            // Better approach for balanced sum: 
            // Sort by HCP. Place 1st into Group 1, 2nd into Group 2... 
            // When reaching end, reverse direction.
            // Constraint: Must not exceed capacity.

            // Greedy Balanced Algorithm with Capacity Check
            // Sort High to Low.
            // Assign current highest player to the group with the LOWEST current total HCP that isn't full.
            
            // However, Snake is standard for golf.
            // Let's fill slots.
            // Total slots = total people.
            // Groups [4, 4, 3] -> 3 groups.
            // Snake: 0, 1, 2, 2, 1, 0, 0, 1, 2...
            
            listToDistribute.forEach((p, i) => {
                // Find target group index based on snake pattern
                let numGroups = groups.length;
                let round = Math.floor(i / numGroups);
                let isEvenRound = round % 2 === 0;
                let col = i % numGroups;
                let targetIdx = isEvenRound ? col : (numGroups - 1 - col);

                // Check capacity. If target is full (e.g. it's a 3-group and we are in round 4), find neighbor
                if (groups[targetIdx].members.length >= groups[targetIdx].capacity) {
                    // Find first non-full group
                    // Prefer keeping the snake logic: look adjacent? 
                    // Simple fallback: find group with most space or lowest index
                    let bestG = groups.find(g => g.members.length < g.capacity);
                    if (bestG) bestG.members.push(p);
                } else {
                    groups[targetIdx].members.push(p);
                }
            });
        }

        app.data.groups = groups.map(g => g.members);
        app.renderResults();
        app.goToStep(3);
    },

    // --- Step 3: Render Results ---
    renderResults: () => {
        const container = document.getElementById('results-container');
        container.innerHTML = '';

        const groups = app.data.groups;
        let totalP = 0;
        let warning = false;
        let groupSizes = [];

        groups.forEach((members, idx) => {
            if(members.length === 0) return;
            totalP += members.length;
            groupSizes.push(members.length);

            // Valid?
            const isValid = (members.length >= app.config.minGroup && members.length <= app.config.maxGroup);
            if(!isValid) warning = true;

            // Sort internal display by HCP (Low to High for scorecard look)
            members.sort((a,b) => a.hcp - b.hcp);

            const totalHcp = members.reduce((sum, p) => sum + p.hcp, 0);
            
            // Build Move Options
            let moveOpts = '';
            for(let i=0; i<groups.length; i++) {
                moveOpts += `<option value="${i}" ${i === idx ? 'selected' : ''}>${i === idx ? 'ÁõÆÂâçÁµÑÂà•' : 'ÁßªËá≥ G'+(i+1)}</option>`;
            }

            let rows = members.map(p => `
                <tr>
                    <td>
                        <span class="p-name ${p.gender === 'F' ? 'female' : 'male'}">${p.name}</span>
                        <select class="move-select" onchange="app.movePlayer(${p.id}, ${idx}, this.value)">${moveOpts}</select>
                    </td>
                    <td style="text-align:right; font-weight:700; color:#5f6368;">${p.hcp}</td>
                </tr>
            `).join('');

            // Controls
            const upBtn = idx > 0 ? `<button class="arrow-btn" onclick="app.swapGroups(${idx}, -1)">‚ñ≤</button>` : `<div style="width:28px"></div>`;
            const downBtn = idx < groups.length - 1 ? `<button class="arrow-btn" onclick="app.swapGroups(${idx}, 1)">‚ñº</button>` : `<div style="width:28px"></div>`;

            const cardHtml = `
                <div class="scorecard ${isValid ? '' : 'invalid'}">
                    <div class="sc-header">
                        <div>
                            <span class="sc-title">GROUP ${idx + 1}</span>
                            <span class="sc-stats">HCP ${totalHcp}</span>
                        </div>
                        <div class="sc-controls">
                            ${upBtn}${downBtn}
                        </div>
                    </div>
                    <table class="sc-table">
                        ${rows}
                    </table>
                </div>
            `;
            container.innerHTML += cardHtml;
        });

        // Header Stats
        document.getElementById('res-total-players').innerText = `Á∏Ω‰∫∫Êï∏: ${totalP} ‰∫∫`;
        document.getElementById('res-group-structure').innerText = `ÁµÑÂà•ÂàÜÈÖç: ${groupSizes.join(' - ')}`;
        
        const btnExport = document.getElementById('btn-export');
        if (warning) {
            btnExport.classList.replace('btn-success', 'btn-secondary');
            btnExport.innerText = "‚ö†Ô∏è ÁµÑÂà•Á∑®ÊéíÁï∞Â∏∏";
            app.showToast("Ë≠¶ÂëäÔºöÁôºÁèæ‰∏çÁ¨¶Âêà 3-4 ‰∫∫Ë¶èÂâáÁöÑÁµÑÂà•");
        } else {
            btnExport.classList.replace('btn-secondary', 'btn-success');
            btnExport.innerText = "üìã Ë§áË£ΩÊñáÂ≠óÂêçÂñÆ";
        }
    },

    movePlayer: (pid, fromG, toG) => {
        fromG = parseInt(fromG);
        toG = parseInt(toG);
        if (fromG === toG) return;

        // Execute Move
        const pIndex = app.data.groups[fromG].findIndex(p => p.id === pid);
        if (pIndex > -1) {
            const player = app.data.groups[fromG].splice(pIndex, 1)[0];
            app.data.groups[toG].push(player);
            app.renderResults();
        }
    },

    swapGroups: (idx, dir) => {
        const target = idx + dir;
        if (target >= 0 && target < app.data.groups.length) {
            [app.data.groups[idx], app.data.groups[target]] = [app.data.groups[target], app.data.groups[idx]];
            app.renderResults();
        }
    },

    copyToClipboard: () => {
        let text = `‚õ≥Ô∏è È´òÁàæÂ§´ÂàÜÁµÑÂêçÂñÆ\n${new Date().toLocaleDateString()}\n================\n`;
        app.data.groups.forEach((g, i) => {
            if (g.length === 0) return;
            text += `\n[Á¨¨ ${i+1} ÁµÑ] Total HCP: ${g.reduce((s,p)=>s+p.hcp,0)}\n`;
            g.forEach(p => {
                text += `- ${p.name} (${p.hcp})\n`;
            });
        });

        navigator.clipboard.writeText(text).then(() => {
            app.showToast("‚úÖ ÂêçÂñÆÂ∑≤Ë§áË£Ω");
        }).catch(() => {
            app.showToast("‚ùå Ë§áË£ΩÂ§±Êïó");
        });
    }
};

// Init
window.onload = () => {
    // Check if we need to load anything on start
};
</script>

</body>
</html>
